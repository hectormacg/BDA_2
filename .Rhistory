"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
transformed parameters {
real alpha;
alpha = 0.;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] log_lambda;
real beta_3_4_sum;
vector[N] log_lik;
beta_3_4_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik = poisson_log_glm_lpmf(y[n] | X[n], alpha, beta);
yrep[n] = poisson_log_rng(log_lambda[n]);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
View(posterior_samples)
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
transformed parameters {
real alpha;
alpha = 0.;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] log_lambda;
vector[N] lambda;
real beta_3_4_sum;
vector[N] log_lik;
beta_3_4_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
lambda=exp(log_lambda);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik = poisson_lpmf(y[n] | lambda);
\\yrep[n] = poisson_log_rng(log_lambda[n]);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
transformed parameters {
real alpha;
alpha = 0.;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] log_lambda;
vector[N] lambda;
real beta_3_4_sum;
vector[N] log_lik;
beta_3_4_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
lambda=exp(log_lambda);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik = poisson_lpmf(y[n] | lambda);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
transformed parameters {
real alpha;
alpha = 0.;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] log_lambda;
vector[N] lambda;
real beta_3_4_sum;
vector[N] log_lik;
beta_3_4_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
lambda=exp(log_lambda);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = poisson_lpmf(y[n] | lambda);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#to CODA
#---------------------------------------------------------
mcmc_samples <- As.mcmc.list(res.meggs1)
#---------------------------------------------------------
#effectiveSize
#---------------------------------------------------------
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
#---------------------------------------------------------
#gelman plots and metrics
#---------------------------------------------------------
# gelman.diag(mcmc_samples)
# gelman.plot(mcmc_samples)
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
transformed parameters {
real alpha;
alpha = 0.;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
//vector[N] yrep;  //replicates
vector[N] log_lambda;
vector[N] lambda;
real beta_3_4_sum;
vector[N] log_lik;
beta_3_4_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
lambda=exp(log_lambda);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = poisson_lpmf(y[n] | lambda);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#to CODA
#---------------------------------------------------------
mcmc_samples <- As.mcmc.list(res.meggs1)
#---------------------------------------------------------
#effectiveSize
#---------------------------------------------------------
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
#---------------------------------------------------------
#gelman plots and metrics
#---------------------------------------------------------
# gelman.diag(mcmc_samples)
# gelman.plot(mcmc_samples)
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(loo)
#---------------------------------------------------------
#STAN negative Binomial
#---------------------------------------------------------
res.meggs2.1 <- stan(
file = "meggs_poisson.stan",
data = data_meggs,
chains = 1,
iter = 10000, # Adjust based on warmup and thinning to achieve 2500 post-warmup samples
warmup = 1400, # Example
thin = 4
)
#---------------------------------------------------------
# Extracting posterior samples
#---------------------------------------------------------
posterior_samples <- extract(res.meggs2.1)$log_lik
print(dim(posterior_samples))
#---------------------------------------------------------
# Extracting posterior samples
#---------------------------------------------------------
waic(posterior_samples)
#---------------------------------------------------------
#STAN negative Binomial
#---------------------------------------------------------
# Run the model using the stan function
res.meggs2.1 <- stan(
file = "meggs_negbin.stan",
data = data_meggs,
chains = 1,
iter = 10000, # Adjust based on warmup and thinning to achieve 2500 post-warmup samples
warmup = 5000, # Example
thin = 4
)
#---------------------------------------------------------
# Extracting posterior samples
#---------------------------------------------------------
posterior_samples <- extract(res.meggs2.1)$log_lik
#---------------------------------------------------------
# Extracting posterior samples
#---------------------------------------------------------
waic(posterior_samples)
dim(posterior_samples)
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(loo)
#---------------------------------------------------------
#STAN negative Binomial
#---------------------------------------------------------
res.meggs2.1 <- stan(
file = "meggs_poisson.stan",
data = data_meggs,
chains = 1,
iter = 11400, # Adjust based on warmup and thinning to achieve 2500 post-warmup samples
warmup = 1400, # Example
thin = 4
)
#---------------------------------------------------------
# Extracting posterior samples
#---------------------------------------------------------
posterior_samples <- extract(res.meggs2.1)$log_lik
print(dim(posterior_samples))
#---------------------------------------------------------
# Extracting posterior samples
#---------------------------------------------------------
waic(posterior_samples)
#---------------------------------------------------------
#STAN negative Binomial
#---------------------------------------------------------
# Run the model using the stan function
res.meggs2.1 <- stan(
file = "meggs_negbin.stan",
data = data_meggs,
chains = 1,
iter = 11400, # Adjust based on warmup and thinning to achieve 2500 post-warmup samples
warmup = 1400, # Example
thin = 4
)
#---------------------------------------------------------
# Extracting posterior samples
#---------------------------------------------------------
posterior_samples <- extract(res.meggs2.1)$log_lik
#---------------------------------------------------------
# Extracting posterior samples
#---------------------------------------------------------
waic(posterior_samples)
help("waic")
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
transformed parameters {
real alpha;
alpha = 0.;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
//vector[N] yrep;  //replicates
vector[N] log_lambda;
vector[N] lambda;
real beta_3_4_sum;
vector[N] log_lik;
beta_3_4_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
lambda=exp(log_lambda);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = log(poisson_lpmf(y[n] | lambda));
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#to CODA
#---------------------------------------------------------
mcmc_samples <- As.mcmc.list(res.meggs1)
#---------------------------------------------------------
#effectiveSize
#---------------------------------------------------------
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
#---------------------------------------------------------
#gelman plots and metrics
#---------------------------------------------------------
# gelman.diag(mcmc_samples)
# gelman.plot(mcmc_samples)
View(eggs)
