#Model String
#---------------------------------------------------------
model_string_eggs_negbin<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
real m0;
real<lower=0> sigma0;
real<lower=0> sigma1;
}
parameters {
vector[K] beta;
real<lower=0> phi;
}
transformed parameters {
vector[N] eta;
eta = area_log + X * beta;
}
model {
phi ~ gamma(2, 0.01);
beta[1] ~ normal(m0, sigma0);
beta[2:K] ~ normal(0, sigma1);
y ~ neg_binomial_2_log(eta, phi);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] mu;
vector[N] log_lik;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = neg_binomial_2_log_lpmf(y[n] | eta[n], phi);
yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_negbin.stan";
cat(model_string_eggs_negbin,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
mcmc_dens(res.meggs2, pars=c("phi"))
#-------------------------------------------------------------------------------
# Data preparation
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#Index farm
# eggs$j.farm<-as.numeric(as.factor(eggs$farm))
eggs$j.farm<-as.integer(sub("B", "", eggs$farm))
#-------------------------------------------------------------------------------
#model matrix, drop intercept
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)[, -1]
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
M=length(unique(eggs$j.farm))
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#Data
#-------------------------------------------------------------------------------
data_meggs_re=list(N=N, K=K, y=y, X=X, area_log=area_log, j_farm=eggs$j.farm, M=M, sigma1=sigma1);
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin_re<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
int<lower=0> M; // number of farms
matrix[N, K] X;  // matrix design
real<lower=0> sigma1;
vector[N] area_log;
int<lower=1, upper=M> j_farm[N];
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real<lower=0> phi;
real mu_theta;
real<lower=0> tau_theta;
vector[M] theta;
}
transformed parameters {
vector[N] eta;
real<lower=0> sigma_theta;
sigma_theta = 1/sqrt(tau_theta);
for (n in 1:N){
eta[n] =  area_log[n] + X[n] * beta + theta[j_farm[n]];
}
}
model {
phi ~ gamma(2, 0.01);
beta ~ normal(0, sigma1);
mu_theta ~ normal(0, 1);
tau_theta ~ gamma(0.1, 0.1);
theta ~ normal(mu_theta, sigma_theta);
for (n in 1:N){
y[n] ~ neg_binomial_2_log(eta[n], phi);
}
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] mu;
vector[N] log_lik;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = neg_binomial_2_log_lpmf(y[n] | eta[n], phi);
yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_negbin_re.stan";
cat(model_string_eggs_negbin_re,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs_re,
iter = 5000,
chains = 1,
warmup =1400,
cores = parallel::detectCores(),
refresh=0,
seed = 42
)
print(res.meggs2)
y_rep <- extract(res.meggs2)$y_rep  # or replace with your model output
View(y_pred)
y_rep <- extract(res.meggs2)$yrep  # or replace with your model output
View(y_rep)
dim(y_rep)
dim(eggs)
y_rep <- extract(res.meggs2)$yrep  # or replace with your model output
obs_density <- density(eggs$num.eggs)
dim(y_rep)  # Should give [n_draws, n_observations]
xlim_range <- c(0, 200)  # Focus the plot
# Setup plot
plot(obs_density,
col = NA,
main = "Posterior Predictive Densities (4000 simulations)",
xlab = "Egg Count",
ylab = "Density",
ylim = c(0, max(obs_density$y) * 1.1),
xlim = xlim_range)
# Simulated lines
for (i in 1:4000) {
sim_density <- density(y_rep[i, ])
lines(sim_density, col = rgb(0, 0, 1, 0.05))  # transparent blue
}
length(y_rep)
nrow(y_rep)
y_rep <- extract(res.meggs2)$yrep  # or replace with your model output
obs_density <- density(eggs$num.eggs)
dim(y_rep)  # Should give [n_draws, n_observations]
xlim_range <- c(0, 200)  # Focus the plot
# Setup plot
plot(obs_density,
col = NA,
main = "Posterior Predictive Densities (4000 simulations)",
xlab = "Egg Count",
ylab = "Density",
ylim = c(0, max(obs_density$y) * 1.1),
xlim = xlim_range)
# Simulated lines
for (i in 1:nrow(y_rep)) {
sim_density <- density(y_rep[i, ])
lines(sim_density, col = rgb(0, 0, 1, 0.05))  # transparent blue
}
# Observed line
lines(obs_density, col = "red", lwd = 2)
legend("topright",
legend = c("Simulated", "Observed"),
col = c("blue", "red"),
lwd = c(1, 2),
bty = "n")
yrep.samples<-extract(res.meggs2)$yrep
y<-eggs$num.eggs
yrep.samples.min=apply(yrep.samples,MARGIN=1, FUN=min)
yrep.samples.max=apply(yrep.samples,MARGIN=1, FUN=max)
yrep.samples.median=apply(yrep.samples,MARGIN=1, FUN=median)
require(fBasics)
yrep.samples.kurtosis=apply(yrep.samples,MARGIN=1, FUN=kurtosis)
yrep.samples.skewness=apply(yrep.samples,MARGIN=1, FUN=skewness)
par(mfrow=c(3,2))
hist(yrep.samples.min,col="gray40",main="Predictive distribution for min")
abline(v=min(y),col="red",lwd=2)
hist(yrep.samples.max,col="gray40",main="Predictive distribution for max")
abline(v=max(y),col="red",lwd=2)
hist(yrep.samples.median,col="gray40",main="Predictive distribution for median")
abline(v=median(y),col="red",lwd=2)
hist(yrep.samples.kurtosis,col="gray40",main="Predictive distribution for kurtosis")
abline(v=kurtosis(y),col="red",lwd=2)
hist(yrep.samples.skewness,col="gray40",main="Predictive distribution for skewness")
abline(v=skewness(y),col="red",lwd=2)
par(mfrow=c(1,1))
length(yrep.samples.min)
#-------------------------------------------------------------------------------
# Data preparation
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#Index farm
# eggs$j.farm<-as.numeric(as.factor(eggs$farm))
eggs$j.farm<-as.integer(sub("B", "", eggs$farm))
#-------------------------------------------------------------------------------
#model matrix, drop intercept
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)[, -1]
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
M=length(unique(eggs$j.farm))
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#Data
#-------------------------------------------------------------------------------
data_meggs_re=list(N=N, K=K, y=y, X=X, area_log=area_log, j_farm=eggs$j.farm, M=M, sigma1=sigma1);
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin_re<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
int<lower=0> M; // number of farms
matrix[N, K] X;  // matrix design
real<lower=0> sigma1;
vector[N] area_log;
int<lower=1, upper=M> j_farm[N];
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real<lower=0> phi;
real mu_theta;
real<lower=0> tau_theta;
vector[M] theta;
}
transformed parameters {
vector[N] eta;
real<lower=0> sigma_theta;
sigma_theta = 1/sqrt(tau_theta);
for (n in 1:N){
eta[n] =  area_log[n] + X[n] * beta + theta[j_farm[n]];
}
}
model {
phi ~ gamma(2, 0.01);
beta ~ normal(0, sigma1);
mu_theta ~ normal(0, 1);
tau_theta ~ gamma(0.1, 0.1);
theta ~ normal(mu_theta, sigma_theta);
for (n in 1:N){
y[n] ~ neg_binomial_2_log(eta[n], phi);
}
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] mu;
vector[N] log_lik;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = neg_binomial_2_log_lpmf(y[n] | eta[n], phi);
yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_negbin_re.stan";
cat(model_string_eggs_negbin_re,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs_re,
iter = 3000,
chains = 4,
warmup =2000,
cores = parallel::detectCores(),
refresh=0,
seed = 42
)
print(res.meggs2)
#---------------------------------------------
#Library
require(fBasics)
#---------------------------------------------
#Library
yrep.samples<-extract(res.meggs2)$yrep
y<-eggs$num.eggs
yrep.samples.min=apply(yrep.samples,MARGIN=1, FUN=min)
yrep.samples.max=apply(yrep.samples,MARGIN=1, FUN=max)
yrep.samples.median=apply(yrep.samples,MARGIN=1, FUN=median)
yrep.samples.kurtosis=apply(yrep.samples,MARGIN=1, FUN=kurtosis)
yrep.samples.skewness=apply(yrep.samples,MARGIN=1, FUN=skewness)
par(mfrow=c(3,2))
hist(yrep.samples.min,col="gray40",main="Predictive distribution for min")
abline(v=min(y),col="red",lwd=2)
hist(yrep.samples.max,col="gray40",main="Predictive distribution for max")
abline(v=max(y),col="red",lwd=2)
hist(yrep.samples.median,col="gray40",main="Predictive distribution for median")
abline(v=median(y),col="red",lwd=2)
hist(yrep.samples.kurtosis,col="gray40",main="Predictive distribution for kurtosis")
abline(v=kurtosis(y),col="red",lwd=2)
hist(yrep.samples.skewness,col="gray40",main="Predictive distribution for skewness")
abline(v=skewness(y),col="red",lwd=2)
par(mfrow=c(1,1))
min(yrep.samples.min)
max(yrep.samples.min)
max(yrep.samples.max)
min(yrep.samples.max)
#-------------------------------------------------------------------------------
# Data preparation
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#Index farm
# eggs$j.farm<-as.numeric(as.factor(eggs$farm))
eggs$j.farm<-as.integer(sub("B", "", eggs$farm))
#-------------------------------------------------------------------------------
#model matrix, drop intercept
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)[, -1]
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
M=length(unique(eggs$j.farm))
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#Data
#-------------------------------------------------------------------------------
data_meggs_re=list(N=N, K=K, y=y, X=X, area_log=area_log, j_farm=eggs$j.farm, M=M, sigma1=sigma1);
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin_re<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
int<lower=0> M; // number of farms
matrix[N, K] X;  // matrix design
real<lower=0> sigma1;
vector[N] area_log;
int<lower=1, upper=M> j_farm[N];
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real<lower=0> phi;
real mu_theta;
real<lower=0> tau_theta;
vector[M] theta;
}
transformed parameters {
vector[N] eta;
real<lower=0> sigma_theta;
sigma_theta = 1/sqrt(tau_theta);
for (n in 1:N){
eta[n] =  area_log[n] + X[n] * beta + theta[j_farm[n]];
}
}
model {
phi ~ gamma(2, 0.01);
beta ~ normal(0, sigma1);
mu_theta ~ normal(0, 1);
tau_theta ~ gamma(0.1, 0.1);
theta ~ normal(mu_theta, sigma_theta);
for (n in 1:N){
y[n] ~ neg_binomial_2_log(eta[n], phi);
}
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] mu;
vector[N] log_lik;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = neg_binomial_2_log_lpmf(y[n] | eta[n], phi);
yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_negbin_re.stan";
cat(model_string_eggs_negbin_re,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs_re,
iter = 6000,
chains = 1,
warmup =2000,
cores = parallel::detectCores(),
refresh=0,
seed = 42
)
print(res.meggs2)
#---------------------------------------------
#Library
require(fBasics)
#---------------------------------------------
#Library
yrep.samples<-extract(res.meggs2)$yrep
y<-eggs$num.eggs
yrep.samples.min=apply(yrep.samples,MARGIN=1, FUN=min)
yrep.samples.max=apply(yrep.samples,MARGIN=1, FUN=max)
yrep.samples.median=apply(yrep.samples,MARGIN=1, FUN=median)
yrep.samples.kurtosis=apply(yrep.samples,MARGIN=1, FUN=kurtosis)
yrep.samples.skewness=apply(yrep.samples,MARGIN=1, FUN=skewness)
par(mfrow=c(3,2))
hist(yrep.samples.min,col="gray40",main="Predictive distribution for min")
abline(v=min(y),col="red",lwd=2)
hist(yrep.samples.max,col="gray40",main="Predictive distribution for max")
abline(v=max(y),col="red",lwd=2)
hist(yrep.samples.median,col="gray40",main="Predictive distribution for median")
abline(v=median(y),col="red",lwd=2)
hist(yrep.samples.kurtosis,col="gray40",main="Predictive distribution for kurtosis")
abline(v=kurtosis(y),col="red",lwd=2)
hist(yrep.samples.skewness,col="gray40",main="Predictive distribution for skewness")
abline(v=skewness(y),col="red",lwd=2)
par(mfrow=c(1,1))
ozone <- read.csv("ozone.csv")
head(ozone)
#--------------------------------------------------
#Libraries
library(INLA)
library(inlabru)
library(sf)
library(ggplot2)
#--------------------------------------------------
#data pre-process
#-------------------------------------------------
ozone$year_centered<-ozone$year-mean(ozone$year)
#--------------------------------------------------
#Location mesh
Locations = data.frame(easting=ozone$Longitude, northing=ozone$Latitude)
loc.mesh <- inla.mesh.2d(Locations, max.edge = c(1, 2))
loc.spde = inla.spde2.pcmatern(mesh = loc.mesh,
prior.range = c(1, 0.5),
prior.sigma = c(1, 0.5))
ozone$geometry <- sf::st_as_sf(Locations,
coords = c("easting", "northing"))$geometry
#--------------------------------------------------
#year mesh
year.mesh <- inla.mesh.1d(seq(min(ozone$year_centered), max(ozone$year_centered), length.out = 100))
year.spde <- inla.spde2.pcmatern(mesh = year.mesh,
prior.range = c(1, 0.5),
prior.sigma = c(1, 0.5))
#--------------------------------------------------
#fit
cmp <- o3 ~ floc(geometry, model = loc.spde) +
fyear(year_centered, model = year.spde) +
year_centered + Longitude +Latitude+Intercept(1)
res.ozone1 <- bru(cmp, data = ozone, family = "gaussian",
options = list(control.compute = list(dic = TRUE, cpo = TRUE, waic = TRUE)))
#--------------------------------------------------
#Print mesh
coords<-as.matrix(ozone[, c('Longitude', 'Latitude')])
prdomain <- inla.nonconvex.hull(coords,
convex = -0.03, concave = -0.05,
resolution = c(100, 100))
plot(prdomain)
# prmesh <- inla.mesh.2d(boundary = prdomain,
#                        max.edge = c(1, 2))
# plot(prmesh)
plot(loc.mesh)
points(coords, col="red",pch=20)
summary(res.ozone1)
plot(res.ozone1$marginals.fixed$Intercept, type='l',xlab="x",
ylab="Density",main="Posterior density of B0; intercept")
plot(res.ozone1$marginals.fixed$year_centered,type='l',xlab="x",
ylab="Density",main="Posterior density of B1; year_centered")
plot(res.ozone1$marginals.fixed$Longitude,type='l',xlab="x",
ylab="Density",main="Posterior density of B2; Longitude")
plot(res.ozone1$marginals.fixed$Latitude,type='l',xlab="x",
ylab="Density",main="Posterior density of B3; Latitude")
post.range <- spde.posterior(res.ozone1, name = "fyear", what = "range")
plot(post.range)
post.range <- spde.posterior(res.ozone1, name = "fyear", what = "log.variance")
plot(post.range)
library(RColorBrewer)
pix <- fm_pixels(loc.mesh, dims = c(200, 200),format = "sf")
UK <- map_data(map = "world", region = "UK")
pred <- predict(res.ozone1, newdata = pix, formula=~floc)
ggplot() +
gg(loc.mesh) +
gg(pred, aes(color = mean))+
scale_color_gradientn(colours=brewer.pal(11, "RdYlBu"),limits=range(pred$mean))+
geom_polygon(data = UK, aes(x = long, y = lat, group = group), fill = NA, color = "black")
