}
prior_ranges <- list(c(0.5, 0.5), c(1, 0.5), c(2, 0.5))
prior_sigmas <- list(c(0.5, 0.5))
max_edges <- list(c(1, 2))
# Combination grid
settings <- expand.grid(
prior.range = 1:length(prior_ranges),
prior.sigma = 1:length(prior_sigmas),
max.edge = 1:length(max_edges)
)
# Iterate over all combinations
for (i in 1:nrow(settings)) {
run_and_plot_spatial_correlation(
settings$prior.range[i],
settings$prior.sigma[i],
settings$max.edge[i]
)
}
eggs <- read.csv("caterpillar_eggs.csv")
head(eggs)
rm(list = ls(all = TRUE))
#Do not delete this!
#It clears all variables to ensure reproducibility
eggs <- read.csv("caterpillar_eggs.csv")
head(eggs)
#-------------------------------------------------------------------------------
#Pendientes
# 1) priors, se debe ver si la formula para los priors necesita ser adaptada, pues
# en la formula que se presenta no exites un offset, lo que deberia a entrar a jugar
# de alguna manera.
# 2) gelman.diag and plot tiene que ver como plotear parametros especificos
# 3) poisson log likelihood esta saliendo muy raro el waic, checarlo.
# 4) phi, checar que prior poner.
#-------------------------------------------------------------------------------
#model matrix
eggs$sprayed<-as.factor(eggs$sprayed)
eggs$lead<-as.factor(eggs$lead)
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#priors
#-------------------------------------------------------------------------------
a=min(eggs$num.eggs)
b=max(eggs$num.eggs)
m0=(log(a)+log(b))/2
sigma0=(log(a)-log(b))/2
sigma1=(log(a)-log(b))/2
#-------------------------------------------------------------------------------
#Data
#-------------------------------------------------------------------------------
data_meggs=list(N=N, K=K, y=y, X=X, area_log=area_log);
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
transformed parameters {
real alpha;
alpha = 0.;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
//vector[N] yrep;  //replicates
vector[N] log_lambda;
vector[N] lambda;
real beta_3_4_sum;
vector[N] log_lik;
beta_3_4_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
lambda=exp(log_lambda);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = poisson_lpmf(y[n] | lambda[n]);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#to CODA
#---------------------------------------------------------
mcmc_samples <- As.mcmc.list(res.meggs1)
#---------------------------------------------------------
#effectiveSize
#---------------------------------------------------------
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
#---------------------------------------------------------
#gelman plots and metrics
#---------------------------------------------------------
# gelman.diag(mcmc_samples)
# gelman.plot(mcmc_samples)
#-------------------------------------------------------------------------------
# Data preparation
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#Index farm
# eggs$j.farm<-as.numeric(as.factor(eggs$farm))
eggs$j.farm<-as.integer(sub("B", "", eggs$farm))
#-------------------------------------------------------------------------------
#model matrix, drop intercept
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)[, -1]
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
M=length(unique(eggs$j.farm))
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#Data
#-------------------------------------------------------------------------------
data_meggs_re=list(N=N, K=K, y=y, X=X, area_log=area_log, j_farm=eggs$j.farm, M=M);
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin_re<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
int<lower=0> M; // number of farms
matrix[N, K] X;  // matrix design
vector[N] area_log;
int<lower=1, upper=M> j_farm[N];
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real reciprocal_phi;
real mu_theta;
real<lower=0> tau_theta;
vector[M] theta;
}
transformed parameters {
vector[N] eta;
real phi;
real<lower=0> sigma_theta;
phi = 1. / reciprocal_phi;
sigma_theta = 1/sqrt(tau_theta);
//eta = area_log + X * beta + theta[j_farm];
for (n in 1:N){
eta[n] =  area_log[n] + X[n] * beta + theta[j_farm[n]];
}
}
model {
reciprocal_phi ~ cauchy(0., 5);
//beta[1] ~ normal(0,1.5);
beta ~ normal(0,2);
mu_theta ~ normal(0, 1);
tau_theta ~ gamma(0.1, 0.1);
theta ~ normal(mu_theta, sigma_theta);
for (n in 1:N){
y[n] ~ neg_binomial_2_log(eta[n], phi);
}
}
generated quantities{
//vector[N] yrep;  //replicates
vector[N] mu;
vector[N] log_lik;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = neg_binomial_2_log_lpmf(y[n] | eta[n], phi);
//yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_negbin_re.stan";
cat(model_string_eggs_negbin_re,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs_re,
iter = 5000,
chains = 1,
warmup =1400,
cores = parallel::detectCores(),
refresh=0,
seed = 42
)
print(res.meggs2)
res.meggs2
#-------------------------------------------------------------------------------
# Data preparation
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#Index farm
# eggs$j.farm<-as.numeric(as.factor(eggs$farm))
eggs$j.farm<-as.integer(sub("B", "", eggs$farm))
#-------------------------------------------------------------------------------
#model matrix, drop intercept
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)[, -1]
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
M=length(unique(eggs$j.farm))
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#Data
#-------------------------------------------------------------------------------
data_meggs_re=list(N=N, K=K, y=y, X=X, area_log=area_log, j_farm=eggs$j.farm, M=M);
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin_re<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
int<lower=0> M; // number of farms
matrix[N, K] X;  // matrix design
vector[N] area_log;
int<lower=1, upper=M> j_farm[N];
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real reciprocal_phi;
real mu_theta;
real<lower=0> tau_theta;
}
transformed parameters {
vector[N] eta;
real phi;
real<lower=0> sigma_theta;
phi = 1. / reciprocal_phi;
sigma_theta = 1/sqrt(tau_theta);
//eta = area_log + X * beta + theta[j_farm];
eta[n] =  area_log[n] + X[n] * beta + theta[j_farm[n]];
for (n in 1:N){
eta[n] =  area_log[n] + X[n] * beta + theta[j_farm[n]];
}
}
model {
reciprocal_phi ~ cauchy(0., 5);
//beta[1] ~ normal(0,1.5);
beta ~ normal(0,2);
mu_theta ~ normal(0, 1);
tau_theta ~ gamma(0.1, 0.1);
theta ~ normal(mu_theta, sigma_theta);
for (n in 1:N){
y[n] ~ neg_binomial_2_log(eta[n], phi);
}
}
generated quantities{
//vector[N] yrep;  //replicates
vector[N] mu;
vector[N] log_lik;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = neg_binomial_2_log_lpmf(y[n] | eta[n], phi);
//yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_negbin_re.stan";
cat(model_string_eggs_negbin_re,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs_re,
iter = 5000,
chains = 1,
warmup =1400,
cores = parallel::detectCores(),
refresh=0,
seed = 42
)
#-------------------------------------------------------------------------------
# Data preparation
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#Index farm
# eggs$j.farm<-as.numeric(as.factor(eggs$farm))
eggs$j.farm<-as.integer(sub("B", "", eggs$farm))
#-------------------------------------------------------------------------------
#model matrix, drop intercept
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)[, -1]
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
M=length(unique(eggs$j.farm))
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#Data
#-------------------------------------------------------------------------------
data_meggs_re=list(N=N, K=K, y=y, X=X, area_log=area_log, j_farm=eggs$j.farm, M=M);
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin_re<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
int<lower=0> M; // number of farms
matrix[N, K] X;  // matrix design
vector[N] area_log;
int<lower=1, upper=M> j_farm[N];
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real reciprocal_phi;
real mu_theta;
real<lower=0> tau_theta;
}
transformed parameters {
vector[N] eta;
real phi;
real<lower=0> sigma_theta;
phi = 1. / reciprocal_phi;
sigma_theta = 1/sqrt(tau_theta);
//eta = area_log + X * beta + theta[j_farm];
for (n in 1:N){
eta[n] =  area_log[n] + X[n] * beta + theta[j_farm[n]];
}
}
model {
reciprocal_phi ~ cauchy(0., 5);
//beta[1] ~ normal(0,1.5);
beta ~ normal(0,2);
mu_theta ~ normal(0, 1);
tau_theta ~ gamma(0.1, 0.1);
theta ~ normal(mu_theta, sigma_theta);
for (n in 1:N){
y[n] ~ neg_binomial_2_log(eta[n], phi);
}
}
generated quantities{
//vector[N] yrep;  //replicates
vector[N] mu;
vector[N] log_lik;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = neg_binomial_2_log_lpmf(y[n] | eta[n], phi);
//yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_negbin_re.stan";
cat(model_string_eggs_negbin_re,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs_re,
iter = 5000,
chains = 1,
warmup =1400,
cores = parallel::detectCores(),
refresh=0,
seed = 42
)
#-------------------------------------------------------------------------------
# Data preparation
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#Index farm
# eggs$j.farm<-as.numeric(as.factor(eggs$farm))
eggs$j.farm<-as.integer(sub("B", "", eggs$farm))
#-------------------------------------------------------------------------------
#model matrix, drop intercept
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)[, -1]
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
M=length(unique(eggs$j.farm))
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#Data
#-------------------------------------------------------------------------------
data_meggs_re=list(N=N, K=K, y=y, X=X, area_log=area_log, j_farm=eggs$j.farm, M=M);
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin_re<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
int<lower=0> M; // number of farms
matrix[N, K] X;  // matrix design
vector[N] area_log;
int<lower=1, upper=M> j_farm[N];
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real reciprocal_phi;
real mu_theta;
real<lower=0> tau_theta;
vector[M] theta;
}
transformed parameters {
vector[N] eta;
real phi;
real<lower=0> sigma_theta;
phi = 1. / reciprocal_phi;
sigma_theta = 1/sqrt(tau_theta);
//eta = area_log + X * beta + theta[j_farm];
for (n in 1:N){
eta[n] =  area_log[n] + X[n] * beta + theta[j_farm[n]];
}
}
model {
reciprocal_phi ~ cauchy(0., 5);
//beta[1] ~ normal(0,1.5);
beta ~ normal(0,2);
mu_theta ~ normal(0, 1);
tau_theta ~ gamma(0.1, 0.1);
theta ~ normal(mu_theta, sigma_theta);
for (n in 1:N){
y[n] ~ neg_binomial_2_log(eta[n], phi);
}
}
generated quantities{
//vector[N] yrep;  //replicates
vector[N] mu;
vector[N] log_lik;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
log_lik[n] = neg_binomial_2_log_lpmf(y[n] | eta[n], phi);
//yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_negbin_re.stan";
cat(model_string_eggs_negbin_re,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs_re,
iter = 5000,
chains = 1,
warmup =1400,
cores = parallel::detectCores(),
refresh=0,
seed = 42
)
print(res.meggs2)
View(X)
View(X)
View(X)
names(X)
View(X)
