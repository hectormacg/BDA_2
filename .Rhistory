library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] log_lambda;
real beta_2_3_sum;
beta_2_3_sum=beta[3] + beta[4];
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
yrep[n] = poisson_log_rng(log_lambda[n]);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#to CODA
#---------------------------------------------------------
mcmc_samples <- As.mcmc.list(res.meggs1)
#---------------------------------------------------------
#effectiveSize
#---------------------------------------------------------
effectiveSize(mcmc_samples[[1]][, c('alpha', 'beta[1]', 'beta[2]', 'beta[3]')])
eggs <- read.csv("caterpillar_eggs.csv")
head(eggs)
rm(list = ls(all = TRUE))
#Do not delete this!
#It clears all variables to ensure reproducibility
eggs <- read.csv("caterpillar_eggs.csv")
head(eggs)
#model matrix
eggs$sprayed<-as.factor(eggs$sprayed)
eggs$lead<-as.factor(eggs$lead)
X<-model.matrix(num.eggs~sprayed+lead+sprayed*lead, data = eggs)
#-------------------------------------------------------------------------------
#offset
area_log<-log(eggs$area)
#-------------------------------------------------------------------------------
#dimensions
K=ncol(X)
N=nrow(X)
#-------------------------------------------------------------------------------
#Response variable
y<-eggs$num.eggs
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#DATA
#-------------------------------------------------------------------------------
data_meggs=list(N=N, K=K, y=y, X=X, area_log=area_log);
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] log_lambda;
real beta_2_3_sum;
beta_2_3_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
yrep[n] = poisson_log_rng(log_lambda[n]);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#to CODA
#---------------------------------------------------------
mcmc_samples <- As.mcmc.list(res.meggs1)
#---------------------------------------------------------
#effectiveSize
#---------------------------------------------------------
effectiveSize(mcmc_samples[[1]][, c('beta[0]', 'beta[1]', 'beta[2]', 'beta[3]')])
# #---------------------------------------------------------
# #Libraries
# #---------------------------------------------------------
# library(rstan)
# library(coda)
# #---------------------------------------------------------
# #Initialize Stan
# #---------------------------------------------------------
# options(mc.cores = parallel::detectCores())
# stan_version()
# #---------------------------------------------------------
# #Model String
# #---------------------------------------------------------
# model_string_eggs_poisson<-"
# data {
#     int<lower=0> N; // number of observations
#     int<lower=0> K; // number of predictors
#     matrix[N, K] X;  // matrix design
#     vector[N] area_log;
#     int y[N]; // observed counts
# }
# parameters {
#     vector[K] beta;
# }
#
# model {
#     beta[1] ~ normal(0,1.5);
#     beta[2:K] ~ normal(0,1);
#     y ~ poisson_log(area_log + X * beta);
# }
#
# generated quantities{
#     vector[N] yrep;  //replicates
#     vector[N] log_lambda;
#     real beta_2_3_sum;
#     beta_2_3_sum=exp(beta[3] + beta[4]);
#
#     // Calculate linear predictor (log rate parameter) efficiently
#     log_lambda =  area_log + X * beta;
#
#     // Generate replicated data using vectorized _rng form
#     for (n in 1:N) {
#          yrep[n] = poisson_log_rng(log_lambda[n]);
#     }
# }
# "
# fname="meggs_poisson.stan";
# cat(model_string_eggs_poisson,file=fname,append=FALSE);
# #---------------------------------------------------------
# #Calling STAN
# #---------------------------------------------------------
# res.meggs1<- stan(file = fname, data = data_meggs,
#                   iter = 3000,
#                   chains = 4,
#                   warmup =1400,
#                   cores = parallel::detectCores(),
#                   refresh=0)
#---------------------------------------------------------
#to CODA
#---------------------------------------------------------
mcmc_samples <- As.mcmc.list(res.meggs1)
#---------------------------------------------------------
#effectiveSize
#---------------------------------------------------------
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
#---------------------------------------------------------
#gelman plots and metrics
#---------------------------------------------------------
# gelman.diag(mcmc_samples)
# gelman.plot(mcmc_samples)
#---------------------------------------------
#Results
#---------------------------------------------
summary(res.meggs1)$summary[c("beta[0]","beta[1]","beta[2]","beta[3]", "beta_2_3_sum"), ]
#---------------------------------------------
#Results
#---------------------------------------------
summary(res.meggs1)$summary[c("beta[1]","beta[2]","beta[3]","beta[4]", "beta_2_3_sum"), ]
#---------------------------------------------
#Posterior densities
#---------------------------------------------
library(bayesplot)
mcmc_dens(res.meggs1, pars=c("beta[1]","beta[2]","beta[3]","beta[4]", "beta_2_3_sum"))
#---------------------------------------------
#Results
#---------------------------------------------
summary(res.meggs1)$summary[c("beta[1]","beta[2]","beta[3]","beta[4]", "beta_3_4_sum"), ]
#---------------------------------------------------------
#Libraries
#---------------------------------------------------------
library(rstan)
library(coda)
#---------------------------------------------------------
#Initialize Stan
#---------------------------------------------------------
options(mc.cores = parallel::detectCores())
stan_version()
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_poisson<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
}
model {
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ poisson_log(area_log + X * beta);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] log_lambda;
real beta_3_4_sum;
beta_3_4_sum=exp(beta[3] + beta[4]);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  area_log + X * beta;
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
yrep[n] = poisson_log_rng(log_lambda[n]);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_poisson,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs1<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#to CODA
#---------------------------------------------------------
mcmc_samples <- As.mcmc.list(res.meggs1)
#---------------------------------------------------------
#effectiveSize
#---------------------------------------------------------
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
effectiveSize(mcmc_samples[[1]][, c('beta[1]', 'beta[2]', 'beta[3]', 'beta[4]')])
#---------------------------------------------------------
#gelman plots and metrics
#---------------------------------------------------------
# gelman.diag(mcmc_samples)
# gelman.plot(mcmc_samples)
#---------------------------------------------
#Results
#---------------------------------------------
summary(res.meggs1)$summary[c("beta[1]","beta[2]","beta[3]","beta[4]", "beta_3_4_sum"), ]
#---------------------------------------------
#Posterior densities
#---------------------------------------------
library(bayesplot)
mcmc_dens(res.meggs1, pars=c("beta[1]","beta[2]","beta[3]","beta[4]", "beta_3_4_sum"))
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real reciprocal_phi;
eta = area_log + X * beta;
phi = 1. / reciprocal_phi;
}
model {
reciprocal_phi ~ cauchy(0., reciprocal_phi_scale);
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ neg_binomial_2_log(eta, phi);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] mu;
mu = exp(eta);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  eta;
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
yrep[n] = poisson_log_rng(log_lambda[n]);
yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_negbin,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real reciprocal_phi;
}
transformed parameters {
vector[N] eta;
real phi;
eta = area_log + X * beta;
phi = 1. / reciprocal_phi;
}
model {
reciprocal_phi ~ cauchy(0., reciprocal_phi_scale);
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ neg_binomial_2_log(eta, phi);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] mu;
mu = exp(eta);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  eta;
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
yrep[n] = poisson_log_rng(log_lambda[n]);
yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_negbin,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real reciprocal_phi;
}
transformed parameters {
vector[N] eta;
real phi;
eta = area_log + X * beta;
phi = 1. / reciprocal_phi;
}
model {
reciprocal_phi ~ cauchy(0., 5);
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ neg_binomial_2_log(eta, phi);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] mu;
mu = exp(eta);
// Calculate linear predictor (log rate parameter) efficiently
log_lambda =  eta;
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
yrep[n] = poisson_log_rng(log_lambda[n]);
yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_negbin,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
#Model String
#---------------------------------------------------------
model_string_eggs_negbin<-"
data {
int<lower=0> N; // number of observations
int<lower=0> K; // number of predictors
matrix[N, K] X;  // matrix design
vector[N] area_log;
int y[N]; // observed counts
}
parameters {
vector[K] beta;
real reciprocal_phi;
}
transformed parameters {
vector[N] eta;
real phi;
eta = area_log + X * beta;
phi = 1. / reciprocal_phi;
}
model {
reciprocal_phi ~ cauchy(0., 5);
beta[1] ~ normal(0,1.5);
beta[2:K] ~ normal(0,1);
y ~ neg_binomial_2_log(eta, phi);
}
generated quantities{
vector[N] yrep;  //replicates
vector[N] mu;
mu = exp(eta);
// Generate replicated data using vectorized _rng form
for (n in 1:N) {
yrep[n] = neg_binomial_2_rng(mu[n], phi);
}
}
"
fname="meggs_poisson.stan";
cat(model_string_eggs_negbin,file=fname,append=FALSE);
#---------------------------------------------------------
#Calling STAN
#---------------------------------------------------------
res.meggs2<- stan(file = fname, data = data_meggs,
iter = 3000,
chains = 4,
warmup =1400,
cores = parallel::detectCores(),
refresh=0)
#---------------------------------------------------------
help("waic")
